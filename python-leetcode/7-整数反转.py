class Solution(object):
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        x_, y = abs(x), 0
        boundry = (1 << 31) - 1 if x > 0 else 1 << 31  # 都当正数处理，只不过原来的正负数的boundary不同
        while x_ != 0:
            y = y * 10 + x_ % 10
            # print(x % 10)
            if y > boundry:  # 在中间判断就当pruning了。不过在C是不能这么写吧，毕竟会真的溢出
                return 0
            x_ //= 10
        return y if x > 0 else -y


if __name__ == '__main__':
    S = Solution()
    print(S.reverse(312))
'''
print(-1 % 10) #9
print(eval('0x7fffffff')) #2147483647
print(1<<31) #2147483648

(a & b)
按位与运算符：参与运算的两个值，如果两个相应位都为 1，则该位的结果为 1，否则为 0	。
输出结果 12 ，二进制解释： 0000 1100

(a | b)
按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	
输出结果 61 ，二进制解释： 0011 1101

(a ^ b)
按位异或运算符：当两对应的二进位相异时，结果为 1	
输出结果 49 ，二进制解释： 0011 0001

(~a )
按位取反运算符：对数据的每个二进制位取反，即把 1 变为 0，把 0 变为 1 。~x 类似于 -x-1	
输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。

a << 2 
左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补 0。
输出结果 240 ，二进制解释： 1111 0000

a >> 2
右移动运算符：把 ">>" 左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数	
输出结果 15 ，二进制解释： 0000 1111
'''